<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>The Postgres Heap file | 2 TOASTing -</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="The Postgres Heap file | 2 TOASTing"><meta property="og:description" content="Postgres uses a technique called TOAST (The Oversized-Attribute Storage Technique) to deal with tuples that can&rsquo;t fit in a page. Essentially TOASTing allows individual elements in a tuple to be compressed and/or stored &ldquo;out of line&rdquo; in another table called the relation&rsquo;s TOAST table. The process of compressing or storing out of line is called TOASTing, while the reverse is called de-TOASTing (duh).
Only variable length data types can be TOASTed."><meta property="og:type" content="article"><meta property="og:url" content="/posts/postgres_heapfile2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-23T11:44:25+02:00"><meta property="article:modified_time" content="2022-10-23T11:44:25+02:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=IBM%20Plex%20Mono&display=swap"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>The Postgres Heap file | 2 TOASTing</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-10-23T11:44:25+02:00>October 23, 2022</time></div></div></header><div class="content post__content clearfix"><p>Postgres uses a technique called <a href=https://www.postgresql.org/docs/14/storage-TOAST.html>TOAST</a> (The Oversized-Attribute Storage Technique) to deal with tuples that can&rsquo;t fit in a page. Essentially TOASTing allows individual elements in a tuple to be compressed and/or stored &ldquo;out of line&rdquo; in another table called the relation&rsquo;s TOAST table. The process of compressing or storing out of line is called TOASTing, while the reverse is called de-TOASTing (duh).</p><p>Only variable length data types can be TOASTed. After all, why compress an integer that is always 4 bytes in size? Variable length data type are stored in pedestrian fashion: with an integer containing the byte length (including the bytes for the length itself), followed by payload bytes. The TOAST system uses up two bits of the length (higher order on big endian, lower order on little endian) to denote the state of the element (whether it has been compressed, stored out of line, etc.)</p><p>A TOASTable tuple element can be in one of 4 states:</p><table><thead><tr><th>TOAST bits</th><th>Name</th><th>Description</th><th>Maximum size (inline)</th></tr></thead><tbody><tr><td>00</td><td>Regular</td><td>Uncompressed, inline storage with 4-byte length.</td><td>~8000 bytes, due to page size.</td></tr><tr><td>1(0/1)</td><td>Short form</td><td>Unaligned, uncompressed, inline storage with 7-bit length.</td><td>127 bytes, due to 7-bit length.</td></tr><tr><td>10(000000)</td><td>Out of line</td><td>Out of line storage.</td><td>N/A</td></tr><tr><td>01</td><td>Inline compressed</td><td>Compressed, inline storage with 4-byte length</td><td>~8000 bytes, due to page size.</td></tr></tbody></table><p>Elements stored in short form are not aligned to 4-byte boundaries. The length consists of the remaining 7 bits in the byte containing TOAST bits.</p><p>When the byte containing the TOAST bits is <code>10000000</code>, the inline datum is not a short form element, but instead a TOAST pointer to the actual data, which is stored out of line in TOAST tables. This does not clash with short form format, since a self-inclusive length can never be 0.</p><p>The next few bytes after the first byte contain the type and size of the TOAST pointer, followed by the pointer itself. Out of line values may be compressed. Compression information is stored in the TOAST pointer.</p><h1 id=making-the-most-out-of-plain-toast>Making the most out of plain TOAST</h1><p>Postgres uses two configuration parameters to trigger the TOAST system: <code>TOAST_TUPLE_THRESHOLD</code>, which (annoyingly) is a compile-time constant set to 2KB by default, and <code>TOAST_TUPLE_TARGET</code>.</p><p>The TOAST system is triggered when a row being inserted into the heap file has size larger than <code>TOAST_TUPLE_THRESHOLD</code>. At this point the system tries to shrink the row to a size smaller than <code>TOAST_TUPLE_TARGET</code> by compressing TOASTable columns. If this fails, the columns are stored out of line in a TOAST table.</p><p><code>TOAST_TUPLE_TARGET</code> is 2KB by default, but can be set during table creation or using an <code>ALTER TABLE</code> statement:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>a<span style=color:#bbb> </span><span style=color:#366>INT</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>PRIMARY</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>KEY</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- set TOAST tuple target
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>-- typically valid values are in the range [128, 8160] bytes
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>)<span style=color:#bbb> </span><span style=color:#069;font-weight:700>WITH</span><span style=color:#bbb> </span>(toast_tuple_target<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>4080</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#09f;font-style:italic>-- Rows present in unary table are not affected immediately,
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>--      instead we have to rewrite the table (e.g. with VACUUM FULL).
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span>(toast_tuple_target<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>4080</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>Postgres also offers more fine-grained control:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>t<span style=color:#bbb> </span>(a<span style=color:#bbb> </span><span style=color:#366>VARCHAR</span>,<span style=color:#bbb> </span>b<span style=color:#bbb> </span><span style=color:#366>INT</span>[],<span style=color:#bbb> </span><span style=color:#069;font-weight:700>c</span><span style=color:#bbb> </span>BYTEA,<span style=color:#bbb> </span>d<span style=color:#bbb> </span>JSONB);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>------ Per-column TOAST configuration
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- Disable compression, out of line storage and short form storage.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>t<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span>PLAIN;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- Allow compression and out of line storage.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>-- Typically this is the default.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>t<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>b<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span>EXTENDED;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- Allow out of line storage, but not compression.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>t<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>c</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>EXTERNAL</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- Allow compression, but not out of line storage.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>t<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>d<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span>MAIN;<span style=color:#bbb>
</span></span></span></code></pre></div><p>What happens if we disable out of line storage for some column, but the row (even after compression) does not fit in a page? In this case the system ignores our bad advice, and stores the column element out of line anyway.</p><p>Postgres allows us to choose the compression algorithm it uses. There&rsquo;s a connection parameter called <a href=https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TOAST-COMPRESSION>default_toast_compression</a> that is consulted when a client inserts TOASTable elements. This can also be overridden for specific columns in the <code>CREATE TABLE</code> statement:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>a<span style=color:#bbb> </span><span style=color:#366>VARCHAR</span><span style=color:#bbb> </span>COMPRESSION<span style=color:#bbb> </span>lz4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>or by running an <code>ALTER TABLE</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span>COMPRESSION<span style=color:#bbb> </span>pglz;<span style=color:#bbb>
</span></span></span></code></pre></div><p>The compression algorithm that was used to compress a particular element can be found using the <a href=https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-DBOBJECT><code>pg_column_compression</code></a> function.</p><p>The two algorithms supported by default are <code>pglz</code> and <code>lz4</code> (since Postgres 14).</p><p>It&rsquo;s worth noting that since Postgres compresses each element separately, the space savings tend to be lower than columnar databases which compress entire columns.</p><p>Let&rsquo;s see an example of TOAST in practice. As our subject we&rsquo;ll use this simple table:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary(a<span style=color:#bbb> </span><span style=color:#366>VARCHAR</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>In order to see out of line storage at work, we need a function that generates uncompressable strings:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>CREATE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>OR</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>REPLACE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>FUNCTION</span><span style=color:#bbb> </span>random_str(len<span style=color:#bbb> </span><span style=color:#366>INT</span>,<span style=color:#bbb> </span>seed<span style=color:#bbb> </span><span style=color:#366>INT</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>RETURNS</span><span style=color:#bbb> </span><span style=color:#366>VARCHAR</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>AS</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#a00;background-color:#faa>$$</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>string_agg(md5((seed<span style=color:#555>+</span>i)::<span style=color:#366>VARCHAR</span>),<span style=color:#bbb> </span><span style=color:#c30>&#39;&#39;</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>generate_series(<span style=color:#f60>1</span>,<span style=color:#bbb> </span>len<span style=color:#555>/</span><span style=color:#069;font-weight:700>octet_length</span>(md5(seed::<span style=color:#366>VARCHAR</span>)))<span style=color:#bbb> </span><span style=color:#069;font-weight:700>AS</span><span style=color:#bbb> </span>i<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#a00;background-color:#faa>$$</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>LANGUAGE</span><span style=color:#bbb> </span><span style=color:#c30>&#39;sql&#39;</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Let&rsquo;s populate the table with one row:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>INSERT</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>INTO</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>random_str(<span style=color:#f60>5000</span>,<span style=color:#bbb> </span><span style=color:#069;font-weight:700>extract</span>(epoch<span style=color:#bbb> </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>now())::<span style=color:#366>INTEGER</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>Each character in a <code>VARCHAR</code> <a href="https://www.postgresql.org/docs/current/multibyte.html#:~:text=The%20character%20set%20support%20in,8,%20and%20Mule%20internal%20code.">takes up at least one byte</a>, making this row significantly larger than <code>TOAST_TUPLE_THRESHOLD</code>.</p><p>Since the row element can&rsquo;t be compressed effectively, its data is stored out of line in the table&rsquo;s <strong>TOAST table</strong>, in the <code>pg_toast</code> schema. The following query gives us the TOAST table&rsquo;s name:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>relname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_class<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>WHERE</span><span style=color:#bbb> </span>oid<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>reltoastrelid<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_class<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>WHERE</span><span style=color:#bbb> </span>relname<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#c30>&#39;unary&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>On my system this returns <code>pg_toast_16384</code>. Selecting all rows from this table:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#555>*</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_toast.pg_toast_16384;<span style=color:#bbb>
</span></span></span></code></pre></div><p>yields</p><table><thead><tr><th>chunk_id</th><th>chunk_seq</th><th>chunk_data</th></tr></thead><tbody><tr><td>16390</td><td>0</td><td>c4ca4238a0b923820dcc509a6f75849bc81e728d9d4c2f6&mldr;</td></tr><tr><td>16390</td><td>1</td><td>29b125f8597834fa83a4ea5d2f1c4608232e07d3aa3d998&mldr;</td></tr><tr><td>16390</td><td>2</td><td>a77393dd069059b7ef840f0c74a814ec9237b6ecec5decc&mldr;</td></tr></tbody></table><p>So the inserted row element was split into 3 chunks. <code>chunk_id</code> identifies the element being chunked, <code>chunk_seq</code> is a serial number assigned to chunks, and <code>chunk_data</code> contains the actual data itself.</p><p>The contents of the <code>unary</code> table are:</p><table><thead><tr><th>a</th></tr></thead><tbody><tr><td>c4ca4238a0b923820dcc509a6f75849bc81e728d9d4c2f6&mldr;</td></tr></tbody></table><p>so as expected, the row is not compressed before chunking. The system realizes that compression is ineffective.</p><p>Compression by itself is much harder to observe. In order to see it in action, let&rsquo;s disable out of line storage:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span>MAIN;<span style=color:#bbb>
</span></span></span></code></pre></div><p>and insert a compressable row:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>TRUNCATE</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>INSERT</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>INTO</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>repeat(<span style=color:#c30>&#39;abcd&#39;</span>,<span style=color:#bbb> </span><span style=color:#f60>2100</span><span style=color:#555>/</span><span style=color:#f60>4</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>The following query gives us the on-disk size of each <code>a</code> element in <code>unary</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>unary.a,<span style=color:#bbb> </span>pg_column_size(unary.a)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>from</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span></code></pre></div><p>and returns</p><table><thead><tr><th>a</th><th>pg_column_size</th></tr></thead><tbody><tr><td>abcdabcdabcdabcdabc&mldr;</td><td>38</td></tr></tbody></table><p>Wait, just 38 bytes? This is much smaller than the expected >2100 bytes, indicating that the row has been compressed and stored inline. (Sceptics can check the TOAST table to confirm that it is empty).</p><p>Now what happens if we insert a row that (even when compressed) can&rsquo;t fit in an 8KB page?</p><p>Running</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>TRUNCATE</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>INSERT</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>INTO</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>random_str(<span style=color:#f60>8200</span>,<span style=color:#bbb> </span><span style=color:#069;font-weight:700>extract</span>(epoch<span style=color:#bbb> </span><span style=color:#069;font-weight:700>from</span><span style=color:#bbb> </span>now())::<span style=color:#366>integer</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- number of chunks used to store the inserted row out of line
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>-- 0 means that the row was stored inline.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>count</span>(<span style=color:#555>*</span>)<span style=color:#bbb> </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>pg_toast.pg_toast_16384;<span style=color:#bbb>
</span></span></span></code></pre></div><p>yields <code>5</code>. The system could not fit the inserted row inline, and resorted to out of line storage despite our instruction.</p><p>Note that if we repeat the same exercise with the storage of <code>a</code> set to <code>PLAIN</code>, we get the following error:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>ERROR: row is too big: size 8224, maximum size 8160
</span></span></code></pre></div><h1 id=how-fast-is-toast>How fast is TOAST?</h1><p>The performance enthusiasts among you may be shaking their heads in dismay at the idea of out of line storage. For every page we scan we may have to fetch many more pages containing chunks of out of line row elements: read amplification! Even worse, these pages are stored in the TOAST table, which is likely to be stored &ldquo;far away&rdquo; from the original relation on disk: random disk I/O!</p><p>Is <code>EXTERNAL</code> storage a performance killer?</p><p>Clearly the worst case scenario here is a full scan of the heap file. (If we&rsquo;re fetching only a few rows, we&rsquo;re probably using indexes anyway.) As a litmus test, let&rsquo;s reconsider the <code>unary</code> table.</p><p>Our control subject is a <code>PLAIN</code> version of <code>unary</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>TRUNCATE</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span>PLAIN;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- insert 10 million rows.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>-- Each row takes up 1 page, so we&#39;re inserting 8 KB * 10e6 = 80 GB.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>INSERT</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>INTO</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span>repeat(<span style=color:#c30>&#39;a&#39;</span>,<span style=color:#bbb> </span><span style=color:#f60>8000</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>generate_series(<span style=color:#f60>0</span>,<span style=color:#bbb> </span><span style=color:#f60>10000000</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- update planner statistics on the unary table.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>ANALYZE</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>EXPLAIN</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>ANALYZE</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#555>*</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Note that 10 million rows occupy a lot more memory than the <a href=https://www.postgresql.org/docs/current/runtime-config-resource.html>default <code>shared_buffers</code></a> setting, so we can&rsquo;t point our fingers at the buffer cache when looking at performance figures.</p><p>Anyway here&rsquo;s the result from that query:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>Seq Scan on unary  (cost=0.00..10100001.01 rows=10000001 width=8004) (actual time=0.200..76959.821 rows=10000001 loops=1)
</span></span><span style=display:flex><span>Planning Time: 0.067 ms
</span></span><span style=display:flex><span>Execution Time: 77294.513 ms
</span></span></code></pre></div><p>Repeating the same query on <code>unary</code> with the <code>STORAGE</code> of <code>a</code> set to <code>EXTERNAL</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>TABLE</span><span style=color:#bbb> </span>unary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>ALTER</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>COLUMN</span><span style=color:#bbb> </span>a<span style=color:#bbb> </span><span style=color:#069;font-weight:700>SET</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>STORAGE</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>EXTERNAL</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>-- rebuilds table. Needed to actually store present rows out of line.
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>-- Added ANALYZE to update table statistics
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>VACUUM</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>FULL</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>ANALYZE</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>EXPLAIN</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>ANALYZE</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#555>*</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>unary;<span style=color:#bbb>
</span></span></span></code></pre></div><p>we get</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>Seq Scan on unary  (cost=0.00..163695.01 rows=10000001 width=18) (actual time=0.048..506.440 rows=10000001 loops=1)
</span></span><span style=display:flex><span>Planning Time: 0.164 ms
</span></span><span style=display:flex><span>Execution Time: 712.174 ms
</span></span></code></pre></div><p>Wait, what? Using TOAST is far faster&mldr;what is going on? Actually this is a pitfall of <code>EXPLAIN ANALYZE</code>: it fetches TOAST pointers from <code>unary</code>&rsquo;s heapfile, but doesn&rsquo;t detoast them. Typically values are detoasted on demand. In this case, we don&rsquo;t need them during query execution proper, so they remain TOASTed until Postgres has to send them to the client (which doesn&rsquo;t happen in an <code>EXPLAIN ANALYZE</code>).</p><p>So in order to run our benchmark we need to fire up <code>bash</code>. Let&rsquo;s use everyone&rsquo;s favourite Postgres command: <code>COPY</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ hyperfine <span style=color:#c30>&#34;sudo -u postgres psql -c &#39;COPY unary TO STDOUT&#39; -o /dev/null&#34;</span>
</span></span><span style=display:flex><span>Benchmark 1: sudo -u postgres psql -c <span style=color:#c30>&#39;COPY unary TO STDOUT&#39;</span> -o /dev/null
</span></span><span style=display:flex><span>  Time <span style=color:#555>(</span>mean ± σ<span style=color:#555>)</span>:     106.450 s ±  0.576 s    <span style=color:#555>[</span>User: 0.003 s, System: 0.002 s<span style=color:#555>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#555>(</span>min … max<span style=color:#555>)</span>:   105.251 s … 107.161 s    <span style=color:#f60>10</span> runs
</span></span></code></pre></div><p>and for the <code>EXTERNAL</code> version:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ hyperfine <span style=color:#c30>&#34;sudo -u postgres psql -c &#39;COPY unary TO STDOUT&#39; -o /dev/null&#34;</span>
</span></span><span style=display:flex><span>Benchmark 1: sudo -u postgres psql -c <span style=color:#c30>&#39;COPY unary TO STDOUT&#39;</span> -o /dev/null
</span></span><span style=display:flex><span>  Time <span style=color:#555>(</span>mean ± σ<span style=color:#555>)</span>:     157.218 s ±  0.596 s    <span style=color:#555>[</span>User: 0.004 s, System: 0.002 s<span style=color:#555>]</span>
</span></span><span style=display:flex><span>  Range <span style=color:#555>(</span>min … max<span style=color:#555>)</span>:   156.579 s … 158.219 s    <span style=color:#f60>10</span> runs
</span></span></code></pre></div><p>So out of line storage incurs a 50% slowdown. Not great. Obviously these figures can vary widely depending on the size of TOASTed values. This case is the most extreme comparision, since for larger rows out of line storage is inevitable.</p><p>Compression, on the other hand almost always speeds things up, as it reduces the number of pages that need to be loaded from disk.</p></div></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/postgres_heapfile/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>The Postgres Heap file | 1</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2022 .
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>